#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!csharp

#r "nuget: ScottPlot, 4.1.29" 
using System; 
using System.Collections.Concurrent; 
using System.Collections.Generic; 
using System.Diagnostics; 
using System.Threading; 
using Microsoft.DotNet.Interactive.Formatting; 
using ScottPlot; 

static void AddItem(BlockingCollection<object> collection)  
{ 
    Monitor.Enter(collection); 
    if (itemsAdded < Math.Pow(10,6)) { 
        collection.Add(new object()); 
        Interlocked.Increment(ref itemsAdded); 
    } 
    if ((itemsAdded == Math.Pow(10,6)) && (collection.Count() == 0)) { 
        collection.CompleteAdding(); 
    } 
    Monitor.Exit(collection); 
} 

static void RemoveItem(BlockingCollection<object> collection) { 
    Monitor.Enter(collection); 
    if (collection.Count >= 1) { 
        collection.Take(); 
    } 
    Monitor.Exit(collection); 
} 


static int itemsAdded = 0;  
long[] blockingCollectionTimes = new long[10]; 
BlockingCollection<object> blockingCollection;  
Thread producerThread, consumerThread; 
AutoResetEvent[] resetEvents; 
Stopwatch stopwatch; 

for (int i = 0; i < 10; i++) { 
    itemsAdded = 0; 
    blockingCollection = new BlockingCollection<object>(); 
    resetEvents = new AutoResetEvent[]{new AutoResetEvent(false), new AutoResetEvent(false)}; 

    producerThread = new Thread(() => { while (!blockingCollection.IsAddingCompleted) { AddItem(blockingCollection); } resetEvents[0].Set(); }); 
    consumerThread = new Thread(() => { while (!blockingCollection.IsAddingCompleted) { RemoveItem(blockingCollection); } resetEvents[1].Set(); }); 

    stopwatch = Stopwatch.StartNew(); 
    producerThread.Start(); 
    consumerThread.Start(); 
    WaitHandle.WaitAll(new WaitHandle[] { resetEvents[0], resetEvents[1] }); 

    stopwatch.Stop(); 
    blockingCollectionTimes[i] = stopwatch.ElapsedMilliseconds; 
}

#!csharp

double[] concurrentQueueTimes = new double[10]; 
ConcurrentQueue<object> concurrentQueue = new ConcurrentQueue<object>(); 
static object dummyObject = new object(); 

for (int i = 0; i < 10; i++) { 
    itemsAdded = 0; 
    resetEvents = new AutoResetEvent[]{new AutoResetEvent(false), new AutoResetEvent(false)}; 

    producerThread = new Thread(() => { while (itemsAdded < Math.Pow(10,6)) {  
        concurrentQueue.Enqueue(new object()); Interlocked.Increment(ref itemsAdded); } resetEvents[0].Set(); }); 
    consumerThread = new Thread(() => { while (!(itemsAdded == Math.Pow(10,6)) || !(concurrentQueue.Count == 0)) {  
        concurrentQueue.TryDequeue(out dummyObject); } resetEvents[1].Set(); }); 

    stopwatch = Stopwatch.StartNew(); 
    producerThread.Start(); 
    consumerThread.Start();  

    WaitHandle.WaitAll(new WaitHandle[] { resetEvents[0], resetEvents[1] }); 

    stopwatch.Stop(); 
    concurrentQueueTimes[i] = stopwatch.ElapsedMilliseconds; 
}

#!csharp

double[] queueTimes = new double[10]; 
Queue<object> queue = new Queue<object>(); 

for (int i = 0; i < 10; i++) { 
    itemsAdded = 0; 
    stopwatch = Stopwatch.StartNew(); 
    for (int j = 0; j < Math.Pow(10,6); j++) { queue.Enqueue(new object()); } 
    for (int j = 0; j < Math.Pow(10,6); j++) { queue.Dequeue(); } 
    stopwatch.Stop(); 
    queueTimes[i] = stopwatch.ElapsedMilliseconds; 
}

#!csharp

double[] blockingCollectionTimesDouble = Array.ConvertAll(blockingCollectionTimes, x => (double)x);
var plot = new ScottPlot.Plot(700, 500);
plot.AddScatter(Enumerable.Range(1, 10).Select(x => x * 1.0).ToArray(), blockingCollectionTimesDouble); 
plot.AddScatter(Enumerable.Range(1, 10).Select(x => x * 1.0).ToArray(), concurrentQueueTimes); 
plot.AddScatter(Enumerable.Range(1, 10).Select(x => x * 1.0).ToArray(), queueTimes); 
plot.SaveFig("graf6.png");
// –≥–æ–ª—É–±–æ–π —Ü–≤–µ—Ç BlockingCollectionüíô
// –∑–µ–ª–µ–Ω—ã–π —Ü–≤–µ—Ç Queueüíö
// –æ—Ä–∞–Ω–∂–µ–≤—ã–π —Ü–≤–µ—Ç ConcurrentQueueüî∂

#!csharp

$"BlockingCollection ‚ñ∂Ô∏è {blockingCollectionTimes.Sum() / 10} –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥üïí\n" + 
$"ConcurrentQueue ‚ñ∂Ô∏è {concurrentQueueTimes.Sum() / 10} –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥üïí\n" + 
$"Queue ‚ñ∂Ô∏è {queueTimes.Sum() / 10} –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥üïí\n" +  
$"–°–∫–æ—Ä–æ—Å—Ç—å —Å–∞–º–æ–π –±—ã—Å—Ç—Ä–æ–π –ø–æ—Ç–æ–∫-–±–µ–∑–æ–ø–∞—Å–Ω–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –æ–±—ã—á–Ω–æ–π –æ—á–µ—Ä–µ–¥—å—é = {100.0 * queueTimes.Sum() / Math.Min(blockingCollectionTimes.Sum(), concurrentQueueTimes.Sum()) - 100:F2}%"

#!csharp

//BlockingCollection ‚ñ∂Ô∏è 924 –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥üïí
//ConcurrentQueue ‚ñ∂Ô∏è 219.4 –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥üïí
//Queue ‚ñ∂Ô∏è 267.3 –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥üïí
//–°–∫–æ—Ä–æ—Å—Ç—å —Å–∞–º–æ–π –±—ã—Å—Ç—Ä–æ–π –ø–æ—Ç–æ–∫-–±–µ–∑–æ–ø–∞—Å–Ω–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –æ–±—ã—á–Ω–æ–π –æ—á–µ—Ä–µ–¥—å—é = 21.83%


//–í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –ø—Ä–æ–¥–µ–ª–∞–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã –º–æ–∂–Ω–æ —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ —Å–∞–º–∞—è –±—ã—Å—Ç—Ä–∞—è –ø–æ—Ç–æ–∫–æ-–±–µ–∑–æ–ø—Å–Ω–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è - ConcurrentQueue. 
//–ü–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –æ–±—ã—á–Ω–æ–π –æ—á–µ—Ä–µ–¥—å—é Queue –∏–º–µ–µ—Ç –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –≤ —Å–∫–æ—Ä–æ—Å—Ç–∏ ~ 21.83%
